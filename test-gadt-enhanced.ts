/**
 * Test file for Enhanced Generalized Algebraic Data Types (GADTs) with Fluent Pattern Matching DSL
 * 
 * This file demonstrates the complete enhanced GADT implementation including:
 * - Fluent pattern-matching DSL with type narrowing
 * - Auto-generated matchers for any GADT type
 * - Kind-aware GADT integration with HKT system
 * - Integration with Derivable Instances framework
 * - Real-world examples showing compile-time type safety
 */

import {
  GADT, GADTTags, GADTPayload,
  pmatch, PatternMatcherBuilder,
  derivePatternMatcher, createPmatchBuilder,
  Expr, ExprK, evaluate, transformString, ExprFunctor,
  MaybeGADT, MaybeGADTK, MaybeGADTFunctor, MaybeGADTApplicative, MaybeGADTMonad,
  EitherGADT, EitherGADTK, EitherGADTBifunctor,
  Result, ResultK, ResultFunctor, deriveResultMonad,
  exampleMaybePmatch, exampleEitherPmatch, exampleExprPmatch, exampleExprFunctor, exampleResultIntegration
} from './fp-gadt-enhanced';

import {
  Kind1, Kind2,
  Apply, ArrayK, MaybeK, EitherK,
  Array, Maybe, Either
} from './fp-hkt';

import {
  Functor, Applicative, Monad, Bifunctor,
  deriveFunctor, deriveApplicative, deriveMonad,
  lift2, composeK, sequence, traverse
} from './fp-typeclasses-hkt';

// ============================================================================
// Fluent Pattern Matching DSL Tests
// ============================================================================

/**
 * Test the fluent pattern matching DSL
 */
export function testFluentPatternMatching(): void {
  console.log('=== Testing Fluent Pattern Matching DSL ===');
  
  // Test MaybeGADT with fluent DSL
  const justValue = MaybeGADT.Just(42);
  const nothingValue = MaybeGADT.Nothing();
  
  const justResult = pmatch(justValue)
    .with('Just', ({ value }) => `Got value: ${value}`)
    .with('Nothing', () => 'No value')
    .exhaustive();
  
  const nothingResult = pmatch(nothingValue)
    .with('Just', ({ value }) => `Got value: ${value}`)
    .with('Nothing', () => 'No value')
    .exhaustive();
  
  console.log('MaybeGADT Just (fluent DSL):', justResult); // "Got value: 42"
  console.log('MaybeGADT Nothing (fluent DSL):', nothingResult); // "No value"
  
  // Test partial matching
  const partialResult = pmatch(justValue)
    .with('Just', ({ value }) => `Got value: ${value}`)
    .partial();
  
  console.log('MaybeGADT partial match:', partialResult); // "Got value: 42"
  
  // Test EitherGADT with fluent DSL
  const leftValue = EitherGADT.Left('error');
  const rightValue = EitherGADT.Right(123);
  
  const leftResult = pmatch(leftValue)
    .with('Left', ({ value }) => `Error: ${value}`)
    .with('Right', ({ value }) => `Success: ${value}`)
    .exhaustive();
  
  const rightResult = pmatch(rightValue)
    .with('Left', ({ value }) => `Error: ${value}`)
    .with('Right', ({ value }) => `Success: ${value}`)
    .exhaustive();
  
  console.log('EitherGADT Left (fluent DSL):', leftResult); // "Error: error"
  console.log('EitherGADT Right (fluent DSL):', rightResult); // "Success: 123"
}

/**
 * Test type narrowing in fluent DSL
 */
export function testTypeNarrowing(): void {
  console.log('\n=== Testing Type Narrowing in Fluent DSL ===');
  
  // Test that payload types are correctly narrowed
  const maybe = MaybeGADT.Just('hello');
  
  const result = pmatch(maybe)
    .with('Just', ({ value }) => {
      // TypeScript should know that value is string here
      console.log('Value type is narrowed to:', typeof value); // "string"
      return value.toUpperCase();
    })
    .with('Nothing', () => 'NO VALUE')
    .exhaustive();
  
  console.log('Type narrowed result:', result); // "HELLO"
  
  // Test with EitherGADT
  const either = EitherGADT.Right(42);
  
  const eitherResult = pmatch(either)
    .with('Left', ({ value }) => {
      // TypeScript should know that value is the left type
      console.log('Left value type:', typeof value);
      return `Error: ${value}`;
    })
    .with('Right', ({ value }) => {
      // TypeScript should know that value is the right type
      console.log('Right value type:', typeof value); // "number"
      return `Success: ${value * 2}`;
    })
    .exhaustive();
  
  console.log('Either type narrowed result:', eitherResult); // "Success: 84"
}

// ============================================================================
// Auto-Generated Matchers Tests
// ============================================================================

/**
 * Test auto-generated matchers
 */
export function testAutoGeneratedMatchers(): void {
  console.log('\n=== Testing Auto-Generated Matchers ===');
  
  // Test MaybeGADT auto-generated matcher
  const maybeMatcher = createPmatchBuilder<MaybeGADT<any>, string>({
    Just: ({ value }) => `Got ${value}`,
    Nothing: () => 'No value'
  });
  
  const justValue = MaybeGADT.Just(42);
  const nothingValue = MaybeGADT.Nothing();
  
  const autoJustResult = maybeMatcher(justValue).exhaustive();
  const autoNothingResult = maybeMatcher(nothingValue).exhaustive();
  
  console.log('MaybeGADT auto-generated Just:', autoJustResult); // "Got 42"
  console.log('MaybeGADT auto-generated Nothing:', autoNothingResult); // "No value"
  
  // Test partial auto-generated matcher
  const partialMaybeMatcher = createPmatchBuilder<MaybeGADT<any>, string>({
    Just: ({ value }) => `Got ${value}`
    // Missing Nothing case - will be undefined
  });
  
  const partialJustResult = partialMaybeMatcher(justValue).partial();
  const partialNothingResult = partialMaybeMatcher(nothingValue).partial();
  
  console.log('MaybeGADT partial auto-generated Just:', partialJustResult); // "Got 42"
  console.log('MaybeGADT partial auto-generated Nothing:', partialNothingResult); // undefined
  
  // Test EitherGADT auto-generated matcher
  const eitherMatcher = createPmatchBuilder<EitherGADT<string, number>, string>({
    Left: ({ value }) => `Error: ${value}`,
    Right: ({ value }) => `Success: ${value}`
  });
  
  const leftValue = EitherGADT.Left('error');
  const rightValue = EitherGADT.Right(123);
  
  const autoLeftResult = eitherMatcher(leftValue).exhaustive();
  const autoRightResult = eitherMatcher(rightValue).exhaustive();
  
  console.log('EitherGADT auto-generated Left:', autoLeftResult); // "Error: error"
  console.log('EitherGADT auto-generated Right:', autoRightResult); // "Success: 123"
}

// ============================================================================
// Kind-Aware GADT Integration Tests
// ============================================================================

/**
 * Test Kind-aware GADT integration with HKT system
 */
export function testKindAwareIntegration(): void {
  console.log('\n=== Testing Kind-Aware GADT Integration ===');
  
  // Test MaybeGADT as HKT
  const maybeArray: Apply<MaybeGADTK, [Array<number>]> = MaybeGADT.Just([1, 2, 3]);
  const maybeNothing: Apply<MaybeGADTK, [Array<number>]> = MaybeGADT.Nothing();
  
  // Use the Functor instance
  const mapped = MaybeGADTFunctor.map(maybeArray, arr => arr.length);
  const mappedNothing = MaybeGADTFunctor.map(maybeNothing, arr => arr.length);
  
  console.log('MaybeGADT Functor map:', mapped); // Just(3)
  console.log('MaybeGADT Functor map (Nothing):', mappedNothing); // Nothing
  
  // Test Applicative
  const lifted = MaybeGADTApplicative.of((x: number) => x * 2);
  const applied = MaybeGADTApplicative.ap(lifted, MaybeGADT.Just(5));
  console.log('MaybeGADT Applicative ap:', applied); // Just(10)
  
  // Test Monad
  const chained = MaybeGADTMonad.chain(
    MaybeGADT.Just(5),
    x => x > 3 ? MaybeGADT.Just(x * 2) : MaybeGADT.Nothing()
  );
  console.log('MaybeGADT Monad chain:', chained); // Just(10)
  
  // Test EitherGADT as HKT
  const eitherResult: Apply<EitherGADTK, [string, number]> = EitherGADT.Right(42);
  const bimapped = EitherGADTBifunctor.bimap(
    eitherResult,
    (err: string) => `Error: ${err}`,
    (val: number) => val * 2
  );
  console.log('EitherGADT Bifunctor bimap:', bimapped); // Right(84)
}

/**
 * Test GADT with generic algorithms
 */
export function testGADTWithGenericAlgorithms(): void {
  console.log('\n=== Testing GADT with Generic Algorithms ===');
  
  // Use lift2 with MaybeGADT
  const add = (a: number, b: number) => a + b;
  const maybeLift2 = lift2(MaybeGADTApplicative)(add);
  
  const result1 = maybeLift2(MaybeGADT.Just(5), MaybeGADT.Just(3));
  const result2 = maybeLift2(MaybeGADT.Just(5), MaybeGADT.Nothing());
  
  console.log('MaybeGADT lift2 (Just, Just):', result1); // Just(8)
  console.log('MaybeGADT lift2 (Just, Nothing):', result2); // Nothing
  
  // Use composeK with MaybeGADT
  const safeDivide = (n: number) => (d: number): MaybeGADT<number> => 
    d === 0 ? MaybeGADT.Nothing() : MaybeGADT.Just(n / d);
  
  const safeSqrt = (n: number): MaybeGADT<number> => 
    n < 0 ? MaybeGADT.Nothing() : MaybeGADT.Just(Math.sqrt(n));
  
  const composed = composeK(MaybeGADTMonad)(safeSqrt, safeDivide(16));
  
  console.log('MaybeGADT composeK (4):', composed(4)); // Just(2)
  console.log('MaybeGADT composeK (0):', composed(0)); // Nothing
}

// ============================================================================
// Expr GADT Tests with Kind Integration
// ============================================================================

/**
 * Test Expr GADT with Kind integration
 */
export function testExprGADTWithKind(): void {
  console.log('\n=== Testing Expr GADT with Kind Integration ===');
  
  // Test Expr evaluation with fluent DSL
  const expr: Expr<number> = Expr.Add(
    Expr.Const(5),
    Expr.Add(Expr.Const(3), Expr.Const(2))
  );
  
  const result = evaluate(expr);
  console.log('Expr evaluation (fluent DSL):', result); // 10
  
  // Test Expr transformation with fluent DSL
  const stringExpr: Expr<string> = Expr.If(
    Expr.Const(true),
    Expr.Const("hello"),
    Expr.Const("world")
  );
  
  const transformed = transformString(stringExpr);
  console.log('Expr transformation (fluent DSL):', transformed);
  
  // Test Expr Functor mapping over constants
  const exprWithConstants: Expr<number> = Expr.Add(
    Expr.Const(5),
    Expr.Const(3)
  );
  
  // Map over the expression, doubling all constants
  const doubled = ExprFunctor.map(exprWithConstants, x => x * 2);
  
  console.log('Original expression:', exprWithConstants);
  console.log('Doubled expression:', doubled);
  console.log('Evaluated doubled:', evaluate(doubled)); // 16
  
  // Test complex expression with Functor
  const complexExpr: Expr<number> = Expr.If(
    Expr.Const(true),
    Expr.Add(Expr.Const(5), Expr.Const(3)),
    Expr.Const(0)
  );
  
  const complexDoubled = ExprFunctor.map(complexExpr, x => x * 2);
  console.log('Complex expression doubled:', evaluate(complexDoubled)); // 16
}

// ============================================================================
// Derivable Instances + Auto-Matchers Tests
// ============================================================================

/**
 * Test Derivable Instances + Auto-Matchers on Result GADT
 */
export function testResultIntegration(): void {
  console.log('\n=== Testing Result GADT Integration ===');
  
  const success = Result.Ok(42);
  const failure = Result.Err('Something went wrong');
  
  // Test auto-generated matcher for Result
  const resultMatcher = createPmatchBuilder<Result<any, any>, string>({
    Ok: ({ value }) => `Success: ${value}`,
    Err: ({ error }) => `Error: ${error}`
  });
  
  const successResult = resultMatcher(success).exhaustive();
  const failureResult = resultMatcher(failure).exhaustive();
  
  console.log('Result success (auto-generated):', successResult); // "Success: 42"
  console.log('Result failure (auto-generated):', failureResult); // "Error: Something went wrong"
  
  // Test derived Monad instance
  const derivedMonad = deriveResultMonad();
  
  const chained = derivedMonad.chain(
    success,
    x => x > 40 ? Result.Ok(x * 2) : Result.Err('Too small')
  );
  
  const chainedResult = resultMatcher(chained).exhaustive();
  console.log('Chained result (derived Monad):', chainedResult); // "Success: 84"
  
  // Test Functor instance
  const mapped = ResultFunctor.map(success, x => x * 2);
  const mappedResult = resultMatcher(mapped).exhaustive();
  console.log('Mapped result (Functor):', mappedResult); // "Success: 84"
  
  // Test with failure
  const mappedFailure = ResultFunctor.map(failure, (x: any) => x * 2);
  const mappedFailureResult = resultMatcher(mappedFailure).exhaustive();
  console.log('Mapped failure (Functor):', mappedFailureResult); // "Error: Something went wrong"
}

// ============================================================================
// Compile-Time Type Safety Demonstrations
// ============================================================================

/**
 * Demonstrate compile-time type safety
 */
export function demonstrateTypeSafety(): void {
  console.log('\n=== Demonstrating Compile-Time Type Safety ===');
  
  // These examples show what would be compile errors:
  
  // 1. Invalid Expr construction (would be compile error)
  // const invalidExpr: Expr<number> = Expr.Add(
  //   Expr.Const("hello"), // Error: string not assignable to number
  //   Expr.Const(3)
  // );
  
  // 2. Incomplete pattern matching (would be compile error)
  // const incompleteMatch = pmatch(MaybeGADT.Just(5))
  //   .with('Just', (value) => value * 2)
  //   .exhaustive(); // Error: Missing 'Nothing' case
  
  // 3. Invalid type application (would be compile error)
  // const invalidApply: Apply<MaybeGADTK, [string, number]> = MaybeGADT.Just("hello");
  // // Error: Too many type arguments for MaybeGADTK
  
  console.log('Type safety demonstrations completed');
  console.log('All invalid combinations would be rejected at compile time');
}

// ============================================================================
// Performance and Integration Tests
// ============================================================================

/**
 * Test performance and integration with existing systems
 */
export function testPerformanceAndIntegration(): void {
  console.log('\n=== Testing Performance and Integration ===');
  
  // Test integration with existing HKT types
  const arrayMaybe: Array<MaybeGADT<number>> = [
    MaybeGADT.Just(1),
    MaybeGADT.Nothing(),
    MaybeGADT.Just(3)
  ];
  
  // Use sequence with MaybeGADT
  const sequenced = sequence(MaybeGADTMonad)(arrayMaybe);
  console.log('Sequence MaybeGADT array:', sequenced); // Nothing (due to Nothing in array)
  
  // Test with all Just values
  const allJust: Array<MaybeGADT<number>> = [
    MaybeGADT.Just(1),
    MaybeGADT.Just(2),
    MaybeGADT.Just(3)
  ];
  
  const sequencedJust = sequence(MaybeGADTMonad)(allJust);
  console.log('Sequence MaybeGADT all Just:', sequencedJust); // Just([1, 2, 3])
  
  // Test traverse
  const numbers = [1, 2, 3, 4, 5];
  const traversed = traverse(MaybeGADTMonad)(
    (n: number) => n > 0 ? MaybeGADT.Just(n * 2) : MaybeGADT.Nothing(),
    numbers
  );
  console.log('Traverse MaybeGADT:', traversed); // Just([2, 4, 6, 8, 10])
  
  // Test with Result GADT
  const results: Array<Result<number, string>> = [
    Result.Ok(1),
    Result.Ok(2),
    Result.Err('error'),
    Result.Ok(4)
  ];
  
  // Filter out errors and get successes
  const successes = results
    .map(result => pmatch(result)
      .with('Ok', ({ value }) => MaybeGADT.Just(value))
      .with('Err', () => MaybeGADT.Nothing())
      .exhaustive()
    )
    .filter(maybe => pmatch(maybe)
      .with('Just', () => true)
      .with('Nothing', () => false)
      .exhaustive()
    );
  
  console.log('Filtered successes:', successes); // [Just(1), Just(2), Just(4)]
}

// ============================================================================
// Real-World Use Cases
// ============================================================================

/**
 * Test real-world use cases
 */
export function testRealWorldUseCases(): void {
  console.log('\n=== Testing Real-World Use Cases ===');
  
  // Example 1: Safe division with MaybeGADT
  const safeDivide = (n: number, d: number): MaybeGADT<number> => 
    d === 0 ? MaybeGADT.Nothing() : MaybeGADT.Just(n / d);
  
  const divisionResult = safeDivide(10, 2);
  const divisionError = safeDivide(10, 0);
  
  const handleDivision = (result: MaybeGADT<number>) => 
    pmatch(result)
      .with('Just', ({ value }) => `Result: ${value}`)
      .with('Nothing', () => 'Division by zero error')
      .exhaustive();
  
  console.log('Safe division (10/2):', handleDivision(divisionResult)); // "Result: 5"
  console.log('Safe division (10/0):', handleDivision(divisionError)); // "Division by zero error"
  
  // Example 2: Error handling with EitherGADT
  const parseNumber = (str: string): EitherGADT<string, number> => {
    const num = parseInt(str, 10);
    return isNaN(num) ? EitherGADT.Left(`Invalid number: ${str}`) : EitherGADT.Right(num);
  };
  
  const validParse = parseNumber('123');
  const invalidParse = parseNumber('abc');
  
  const handleParse = (result: EitherGADT<string, number>) => 
    pmatch(result)
      .with('Left', ({ value }) => `Error: ${value}`)
      .with('Right', ({ value }) => `Parsed: ${value}`)
      .exhaustive();
  
  console.log('Parse number "123":', handleParse(validParse)); // "Parsed: 123"
  console.log('Parse number "abc":', handleParse(invalidParse)); // "Error: Invalid number: abc"
  
  // Example 3: Expression evaluation with type safety
  const complexExpr: Expr<number> = Expr.If(
    Expr.Const(true),
    Expr.Add(Expr.Const(5), Expr.Const(3)),
    Expr.Const(0)
  );
  
  const evalResult = evaluate(complexExpr);
  console.log('Complex expression evaluation:', evalResult); // 8
}

// ============================================================================
// Main Test Runner
// ============================================================================

/**
 * Run all enhanced GADT system tests
 */
export function runAllEnhancedGADTTests(): void {
  console.log('ðŸš€ Running Enhanced Generalized Algebraic Data Types (GADTs) System Tests\n');
  
  testFluentPatternMatching();
  testTypeNarrowing();
  testAutoGeneratedMatchers();
  testKindAwareIntegration();
  testGADTWithGenericAlgorithms();
  testExprGADTWithKind();
  testResultIntegration();
  demonstrateTypeSafety();
  testPerformanceAndIntegration();
  testRealWorldUseCases();
  
  console.log('\nâœ… All enhanced GADT system tests completed successfully!');
  console.log('\nðŸ“‹ Summary:');
  console.log('- âœ… Fluent pattern-matching DSL with type narrowing');
  console.log('- âœ… Auto-generated matchers for any GADT type');
  console.log('- âœ… Kind-aware GADT integration with HKT system');
  console.log('- âœ… Integration with Derivable Instances framework');
  console.log('- âœ… Compile-time type safety demonstrations');
  console.log('- âœ… Real-world use cases with error handling');
  console.log('- âœ… Performance and integration tests');
}

// Run tests if this file is executed directly
if (require.main === module) {
  runAllEnhancedGADTTests();
} 